<?php

namespace Armor\Handle;

use Exception;

// $GLOBALS['__PARSERS'];

/**
 * The route object generated by the `Router` class and used by it. This 
 * is where the path regexes, the parsers and the callback of each path
 * are stored.
 * 
 *  
 * @see \Armor\Handle\Router
 */
class Route {
    /**
     * The regex that provides information about if the path requested corresponds to this route.
     * @var \string
     */
    private $pattern;
    /**
     * The callback that will be used to handle the request.
     * 
     * @var \callable
     */
    private $callback;
    /**
     * The route parameters definitions.
     * 
     * @var \array
     */
    private $parameters;
    /**
     * The parsers of each route parameter, if any.
     * 
     * @var \array
     */
    private $parsers;
    /**
     * The custom parser defined by the framework user. It's should usually be set via `Route#_addParser`,
     * which is accessible via `RouteInterface#setParser`.
     * 
     * @var \callable
     */
    private $customParser;

    /**
     * @param \string $routePath The path that is being expected by the framework user to be requested.
     * @param \callable $routeCallback The callback that will be used to handle the request.
     */
    public function __construct(
        string $routePath,
        callable $routeCallback
    ) {
        list($this->pattern, $this->parameters, $this->parsers) = $this->convertRoutePathToRegex($routePath);
        $this->callback = $routeCallback;
    }

    /**
     * Perform the appropriate parsing to obtain a regex from the path string.
     * 
     * @param \string $routePath The path string to be converted to a "path regex string".
     * @return \array
     */
    private function convertRoutePathToRegex($routePath) {
        $params = array();
        $parsers = array();

        //$pathto = "/user/12085018232";
        //$matching = "/user/$(userid)/$(userconfig)";
        ///@debug print($route . preg_match("/\\$\((\\w+)(.*?)\)/i", $route) . "<br>");

        $routePath = str_replace('-', '\-', $routePath);
        $rgx = preg_replace_callback("/\\$\((\\w+)(.*?)\)/i", function($matches) use(&$params, &$parsers) {
            ///@debug print_r(array_slice($matches, 2));
            $variable = $matches[1];
            $params[$variable] = null;
            $parsers[$variable] = $matches[2];
            return "((?=[A-Za-z0-9\-\._~]+)(?=[0-9A-Fa-f%]*)[A-Za-z0-9\-\._%]+)";
        }, $routePath);

        $rgx = str_replace('/', '\/', $rgx);
        $rgx = "/^" . $rgx . "$/";

        return array($rgx, $params, $parsers);
    }


    /**
     * Returns if the path requested (`$pathto`) can be handled by this route object.
     * And at the same time, only if the path matches, parses the path to get the 
     * "route/path parameters" specified previously.
     * 
     * @param \string $pathto The path requested by the user
     * @return \bool TRUE if it does, FALSE if it doesn't
     */
    public function match(string $pathto) {
        $ROUTE_PARSERS = array(
            'tolower' => function($content) { return strtolower($content); },
            'toupper' => function($content) { return strtoupper($content); },
            'toint' => function($content) { return (int)$content; },
            'tobool' => function($content) { return (bool)$content; }
        );

        $rgxMatches = preg_match($this->pattern, $pathto, $values);

        if (!($rgxMatches) && sizeof($values) <= 0) {
            return false;
        }

        $values = array_slice($values, 1);

        for ($i = 0; $i < sizeof($values); $i++) {
            $key = array_keys($this->parameters)[$i];
            $this->parameters[$key] = urldecode($values[$i]);
            if (array_key_exists($key, $this->parsers) && $this->parsers[$key] && trim($this->parsers[$key]) != '') {
                $parsers = array_filter(explode(':', $this->parsers[$key]), function($item) { return (bool)$item;});
                ///@debug print_r($parsers);
                foreach ($parsers as $parser) {
                    $parser = $parser == 'toparse' ? $this->customParser : $ROUTE_PARSERS[$parser];
                    $this->parameters[$key] = call_user_func($parser, $this->parameters[$key]);
                }
            }
        }

        return $rgxMatches;
    }

    /**
     * Returns the callback setted by the user to the route
     * represented by this class object.
     * 
     * @return \callable
     */
    public function getCallback() { return $this->callback; }

    /**
     * Returns the route/path parameters defined by the user and parsed
     * by this class.
     * 
     * @return \array
     */
    public function getParsedRouteParameters() {
        if (in_array(null, array_values($this->parameters))) throw new Exception("parsing parameters failed", 1);
        
        return $this->parameters;
    }

    /**
     * Sets a custom parser to the value passed to some route/path parameter.
     * The user may not have access to the `Route` object directly, so,
     * this is used by the `RouteInterface` class.
     * 
     * @param \callable $parser The custom parser to be used during the route parameter parsing.
     */
    public function _addParser(callable $parser) {
        $this->customParser = $parser;
    }
}