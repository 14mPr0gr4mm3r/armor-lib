<?php

namespace Armor\Handle;

use Exception;

$GLOBALS['__PARSERS'] = array(
    'tolower' => function($content) { return strtolower($content); },
    'toupper' => function($content) { return strtoupper($content); },
    'toint' => function($content) { return (int)$content; },
    'tobool' => function($content) { return (bool)$content; }
);

/**
 * The route object generated by the `Router` class and used by it. This 
 * is where the path regexes, the parsers and the callback of each path
 * are stored.
 */
class Route {
    private $pattern, $callback;
    private $parameters, $parsers;
    private $customParser;

    public function __construct(
        string $routePattern,
        array $routeParameters,
        callable $routeCallback,
        array $parsers=array()
    ) {
        $this->pattern = $routePattern;
        $this->callback = $routeCallback;
        $this->parameters = $routeParameters;
        $this->parsers = $parsers;
    }

    /**
     * Returns if the path requested (`$pathto`) can be handled by this route object.
     * And at the same time, only if the path matches, parses the path to get the 
     * "path parameters" specified previously.
     * 
     * @param string $pathto The path requested by the user
     * @return bool TRUE if it does, FALSE if it doesn't
     */
    public function match(string $pathto) {
        $rgxMatches = preg_match($this->pattern, $pathto, $values);

        if (!($rgxMatches) && sizeof($values) <= 0) {
            return false;
        }

        $values = array_slice($values, 1);

        for ($i = 0; $i < sizeof($values); $i++) {
            $key = array_keys($this->parameters)[$i];
            $this->parameters[$key] = $values[$i];
            if (array_key_exists($key, $this->parsers) && $this->parsers[$key] && trim($this->parsers[$key]) != '') {
                $parsers = array_filter(explode(':', $this->parsers[$key]), function($item) { return (bool)$item;});
                ///@debug print_r($parsers);
                foreach ($parsers as $parser) {
                    $parser = $parser == 'toparse' ? $this->custom_parser : $GLOBALS['__PARSERS'][$parser];
                    $this->parameters[$key] = call_user_func($parser, $this->parameters[$key]);
                }
            }
        }

        return $rgxMatches;
    }

    public function getCallback() { return $this->callback; }

    public function getParsedRouteParameters() {
        if (in_array(null, array_values($this->parameters))) throw new Exception("parsing parameters failed", 1);
        
        return $this->parameters;
    }

    public function _addParser(callable $parser) {
        $this->custom_parser = $parser;
    }
}